package main;

import java.util.*;
import entity.Player;
import entity.Enemy;
import entity.Entity;
import action.PlayerAction;
import action.EnemyAction;
import collections.LinkedList;
import java.util.InputMismatchException;
import entity.Potion;
import player_management.AccessFile;

/**
 *
 * @author Shawn lee
 */

public class Battle implements Runnable{
    private Entity player;
    private Enemy enemy;
    private boolean playerturn;
    private boolean battleEnded;
    private EnemyAction enemyAction;
    private PlayerAction playerAction;
    private int round;
    private LinkedList<Potion> inventory;
    private Scanner scanner;
    private int originalBaseDamage;
    private int originalAttackRange;

    AccessFile file = new AccessFile();

    public Battle(Player player, Enemy enemy, Scanner scanner){
        this.player = player;
        this.enemy = enemy;
        this.enemyAction = new EnemyAction();
        this.playerAction = new PlayerAction();
        playerturn = true;
        this.round = 1;
        //When playerturn is true the player attacks, if the entity turn is true the enemy attack
        //Determines if the battle ended
        battleEnded = false;
        this.originalBaseDamage = player.getbaseDmg();
        this.originalAttackRange = player.getAttackRange();
        //Testing purposes
        this.inventory = new LinkedList<>();
        randomiseInventory(this.inventory);

        this.scanner = scanner;
    }

    public static void randomiseInventory(LinkedList<Potion> inventory) {
        Random random = new Random();
        int numOfPotions = Potion.potionType.values().length - 1;

        Potion strengthPotion = new Potion("Strength Potion", Potion.potionType.Strength, 5);
        Potion rangePotion = new Potion("Range Potion", Potion.potionType.Range, 2);

        for (int i = 0; i < numOfPotions; i++) {
            int potionID = random.nextInt(2);
            if (potionID == 1) {
                inventory.addTail(strengthPotion);
            } else {
                inventory.addTail(rangePotion);
            }
        }
    }

    //Returns the instructions how the moves player can perform
    public String printActionOption(){
        return "(1) Attack | (2) Move Forwards | (3) Move Backwards | (4) Heal | (5) Inventory\n";
    }
    
    //Generated by AI
    //Creates a visual representation of distance difference
    public String drawDistanceBar(int distance) {
        StringBuilder bar = new StringBuilder();
        bar.append("&"); 
        for (int i = 0; i < distance; i++) {
            bar.append("_"); // underscore for each unit of distance
        }
        bar.append("&");
        return bar.toString();
    }

    
    //Returns the stats of the enemy health, player health and distance difference of the two entity
    public String battleStats(){
        int distance = Entity.calculateDistance(player, enemy); 
        String distanceBar = drawDistanceBar(distance);
        return "\n=========Stats=========\nYour health: " + this.player.getHealth() + "/" + this.player.getMaxHealth() + "\n" +
               "Enemy Health: " + this.enemy.getHealth() + "/" + this.enemy.getMaxHealth() + "\n" +
               "Distance: " + distanceBar + " (" + distance + "m)\n=======================\n";
                
    }
   
    
    public int getRound(){
        return this.round;
    }
    
    //This method is used to get the players input on which potion to use and calling another method to apply the potion effect.
    public void useInventory(Scanner scanner, Entity player){
        //close inventory if inventory is empty
        if(inventory.size == 0){
            System.out.println("You have no Potions!"+ "\n");
        }
        //Checks the users input
        else{
            inventory.displayInventory();
            System.out.print("Select a Potion using the index (type -1 to exit) ");
            int potionindex = scanner.nextInt();

            //Close inventory if -1 is typed
            if(potionindex == -1){
                System.out.println("Inventory closed" + "\n");
            }

            //Using the users input, if there's an index corresponding to the users number than the potion is used.
            try{
                Potion selectedPotion = inventory.removeByIndex(potionindex);
                System.out.println("You have used " + selectedPotion + "\n");
                selectedPotion.usePotion(player);
            }
            //If there is no number corresponding to the index of a potion.
            catch(IndexOutOfBoundsException e){
                System.out.println("Invalid number"+ "\n");
            }
        }
    }
    
    //This method is main method for displaying the interface and calling the nessesary methods
    public boolean battle_interface() throws InputMismatchException{
        int playerinput = 0;
        boolean result;
        System.out.println("_________________________________________Battle Begin!__________________________________________");
        System.out.println(player.getName() + ": lvl " + player.getLevel() + "  vs.  " + enemy.getName() + ": lvl " + enemy.getLevel() + "\n\n");
        //While loop to check if the battle ended or currently hasn't ended
        while(!battleEnded){
            if(playerturn){ //Players turn
                try {
                    System.out.println("********** " + this.player.getName() + "'s turn! " + "[round " + round + "] **********\n" + printActionOption());
                    playerinput = scanner.nextInt();
                    //Check that the player input fits any of the options given
                    while (playerinput != 1 && playerinput != 2 && playerinput != 3 && playerinput != 4 && playerinput != 5) {
                        System.out.println("Invalid input!");
                        playerinput = scanner.nextInt();
                    }
                    switch(playerinput){
                        case 1://Attacking the enemy
                            this.playerAction.attack(enemy, player, round);
                            System.out.println(battleStats());
                            if (this.enemy.getHealth() == 0) {
                                System.out.println("You have defeated " + this.enemy.getName() + ". Battle over!!!\n");
                                //Resets player health to max and reset players base damage to the orginal, and range, entity positions
                                this.player.setHealth(player.getMaxHealth());
                                this.player.setbaseDmg(originalBaseDamage);
                                this.player.setAttackRange(originalAttackRange);
                                this.player.setPosition(1);
                                this.enemy.setPosition(1);

                                battleEnded = true;
                                return true;
                            }
                            playerturn = !playerturn;
                            break;
                        case 2://Moving forward
                            this.playerAction.moveForward(enemy, player);
                            playerturn = !playerturn;
                            break;
                        case 3: //Moving backwards
                            this.playerAction.moveBackward(enemy, player);
                            playerturn = !playerturn;
                            break;
                        case 4://healing the player
                            this.playerAction.heal(this.player);
                            playerturn = !playerturn;
                            break;
                        case 5://Opening inventory and allowing user to use a potion in their inventory
                            useInventory(scanner, player);
                            playerturn = !playerturn;
                            break;
                        default:
                            System.out.println("Invalid input!");

                    }
                }
                //If the players input is not a number
                catch (InputMismatchException e ){
                    System.out.println("Invalid input! " + e.getMessage());
                    scanner.next();
                }


            }
            //The enemies turn
            if(!playerturn){
                System.out.println("********** " + this.enemy.getName() + "'s turn! " + "[round " + round + "] **********");
                //A randomized option of action
                enemy.Action(this.player, enemyAction, round);
                System.out.println(battleStats());
                if (this.player.getHealth() == 0) { //Checks if the player health is 0 than the battle is ended
                    System.out.println("Enemy has defeated you. Battle over!!!\n");

                    //Resets player health to max and reset players base damage to the original, and range, entity positions
                    this.player.setHealth(player.getMaxHealth());
                    this.player.setbaseDmg(originalBaseDamage);
                    this.player.setAttackRange(originalAttackRange);
                    this.player.setPosition(1);
                    this.enemy.setPosition(1);

                    battleEnded = true;
                    return false;
                }
                playerturn = !playerturn;
                round++;
            }
        }
        return false;
    }

    @Override
    public void run() {
        battle_interface();
    }

}
